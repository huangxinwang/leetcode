### Problem 
- 假设一个文件压缩后的表示是

```#3, #5, #6, 2 5, #8...```

”#k“形式的代表这个数字k，两个数字“i j”形式的代表取前 i 个
数字做 j 长的 circular重复，像上面那个表示，前面3个都是表示单个数字，
然后 2 5表示取前2个数字 （既56），组成5个数字，不够的从头再取，所以就是56565
最后上面解压缩后应该为
3, 5, 6, 5, 6, 5, 6, 5, 8...

- [ref](http://www.mitbbs.com/article_t1/JobHunting/32622081_0_2.html)


### Analysis
对input从左往右扫，维持一个hashtable记录前面所出现过所有三位数和它们最后一次
出现的位置，举个例子说明

input：```2 3 4 5 2 3 4 5 1...```

用 digit 代表正在扫描的数字，record表示hashtable：
```
digit  record
2       {}
3       {}
4       {234: 0}
5       {234: 0, 345: 1}
2       {234: 0, 345: 1, 452: 2}
3       {234: 0, 345: 1, 452: 2, 523: 3}
4       {234: 4, 345: 1, 452: 2, 523: 3}
.
.
.
```
此外，在扫描一个数字的时候，如果发现有重复出现的三位数，那么就开始对比下去，
尝试找到最长的match。继续用回上面的例子：

在扫描到第二个4的时候，会发现234重复出现，所以就继续比较input[3] 和 input[7]
, 两个都是5，match，所以继续比较input[4] 和 input[8], 一个是2另一个是1，不匹
配，停止，所以在这次发现重复里面就找到一个长度为4的重复，写下压缩记录"4 4" (
往回退4个数字复制4个), 然后继续扫描下一个数字 1。
